//var news = JSON.parse(http://www.freecodecamp.com/news/hot);
//console.log(news);

var req = new XMLHttpRequest();
req.open("GET", "http://www.freecodecamp.com/news/hot", true);
req.addEventListener("load", function() {
	if (req.status === 200) {
		//What if an entry might be duplicated? These will have different upvotes. One solution would be to use the oldest, adding any upvotes from that same user, and discarding any duplicate entries from another user. Need to check if this happens or not;
		responseOK(JSON.parse(req.response));
	}
	else console.log("Response failed " + req.status + ": " + req.statusText);
});
req.send(null);

function responseOK(response) {
	//console.log(response);
	console.log(response['0']);
	console.log(response['1']);
	console.log(response['2']);
	/*
	var names = []
	response.map(function(entry) {
		names.push(entry.author.username);
	});
	names.sort().map(function(x) {
		console.log(x);
	});
	*/
	
	
	
	//temporary stuff
	
	//story = document.getElementsByClassName("story-container");
	
	//tileByIndex starts empty, array will grow as new tiles are added
	var tileByIndex = document.getElementsByClassName("story-container");
	
	console.log(tileByIndex[0]);
	
	
	console.log("last one");
	console.log(response/*[story.length-1]*/);
	
	console.log("STARTING", response.length, "stories available");
	for (var i = 0; i < response.length; i++) {
		
		var tile = document.createElement("div");
		tile.className = "story-container";
		tile.style.backgroundColor = randomPastel();
		//console.log(document);
		document.getElementById('news-field').appendChild(tile);
		
		
		//create a `storyURL link` within tile. CSS makes it occupy entire tile
		var storyURL = document.createElement("a");
		storyURL.setAttribute('href', response[i].link);
		storyURL.setAttribute('class', 'story-link');
		tile.appendChild(storyURL);
		
		//headline, username and upvotes go INSIDE the storyURL
		var headline = document.createElement("span");
		var username = document.createElement("span");
		var upvotes  = document.createElement("span");
		headline.innerHTML = response[i].headline;
		username.innerHTML = '/' + response[i].author.username;
		upvotes.innerHTML  = response[i].rank;
		headline.setAttribute('class', 'story-headline');
		username.setAttribute('class', 'story-poster');
		upvotes.setAttribute('class', 'story-upvotes');
		storyURL.appendChild(headline);
		storyURL.appendChild(username);
		storyURL.appendChild(upvotes);
		
		headline.style.backgroundColor = randomPastel(0.2);
		
		//tile.innerHTML ='<a href="http://www.google.com/'+i+'"class="story-link" >'+response[i].headline+'</a>';
		
		
				/*
		tileByIndex[i].innerHTML = '<br><a href="http://www.google.com/'+i+'" ><span class="story-link">'+response[i].headline+'</span></a>';
		*/
		
		//MOVE THIS to when the tiles generated by JS (when I write that part)
		//maybe even have 25-30 slides preemptively generated before sending the API request
		
		
		console.log("iteration", i, response[i].timePosted, response[i].rank);
		//Maybe getting the images can be done asyncronously or something. There is an issue where some images will return ERR_FILE_NOT_FOUND, and then we will have to use the user background image instead;
		
		
		
		var imageURL = response[i].image;
		var avatarURL = response[i].author.picture;
		var background = new Image();
		//background.addEventListener("load")
		background.onload = storyImageOK(i);
		background.onerror = storyImageNotOK(i);
		background.src = imageURL;
		
		function storyImageOK(index) {
			var storyImageURL = response[index].image;
			return function() {
				tileByIndex[index].style.backgroundImage = "url('" + storyImageURL + "')";
				console.log(index, "OK");
			}
		}
		function storyImageNotOK(index) {
			var userAvatar = response[index].author.picture;
			var pastels;
			return function() {
				tileByIndex[index].style.backgroundImage = "url('" + userAvatar + "')";
				console.log(index, "didn't load")
			}
		}
		
		
	}
}





function randomPastel(alpha) {
	var red   = 128 + Math.floor(Math.random()*128);
	var green = 128 + Math.floor(Math.random()*128);
	var blue  = 128 + Math.floor(Math.random()*128);
	if(alpha) {
		return 'rgba('+red+', '+green+', '+blue+', '+alpha+')';
	}
	return 'rgb('+red+', '+green+', '+blue+')';
}













